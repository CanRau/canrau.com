---
status: draft
slug: /gorilla-csrf-in-remix
lang: en
title: Gorilla/CSRF in Remix üíø
description: Or how to forward a cookie from a Remix Action using `fetch`
version: 1
created: 2022-01-30T13:18:00
updated: 2022-01-30T13:18:00
published: 2022-01-30T13:18:00
meta:
  - name: og:type
    content: article
  - name: article:published_time
    content: 2022-01-30T13:18:00
  - name: article:modified_time
    content: 2022-01-30T13:18:00
  - name: article:author
    content: CanRau
  - name: article:section
    content: Coding
published_at:
---

export const jsonld = {
  "@context": "https://schema.org",
  "@type": "Article",
  headline: "Gorilla/CSRF in Remix üíø",
  description: "Or how to forward a cookie from a Remix Action using `fetch`",
  dateCreated: "2022-01-30T13:18:00",
  dateModified: "2022-01-30T13:18:00",
  datePublished: "2022-01-30T13:18:00",
  author: [
    {
      "@type": "Person",
      name: "Can Rau",
      url: "https://twitter.com/CanRau",
      gender: "Male",
      birthDate: "1988-1-17",
      birthPlace: "Berlin, Germany",
    },
  ],
};

# {frontmatter.title}

## Table of contents

## Intro

As I'm building my API service in GoLang using the [Gorilla Toolkit](https://github.com/gorilla) I
want to share what I learn along the way.

I thought I just quickly add CSRF protection to my API and move on, but as it so sometimes happens,
it took me actually ~2 days üò≥üòÖ which gives even more reason to share how I finally solved it, at
least for me to remember and hopefully save someone else from struggling for days.

> This article is actually for everyone in need of forwarding client cookies from a server context
> (SSR), like a Remix Action in my case.

## What's CSRF

CSRF stand for "Cross-Site Request Forgery" and as summarized by
[OWASP](https://owasp.org/www-community/attacks/csrf) means the following:

> Cross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted actions on a web application in which they‚Äôre currently authenticated. With a little help of social engineering (such as sending a link via email or chat), an attacker may trick the users of a web application into executing actions of the attacker‚Äôs choosing. If the victim is a normal user, a successful CSRF attack can force the user to perform state changing requests like transferring funds, changing their email address, and so forth. If the victim is an administrative account, CSRF can compromise the entire web application.

## Problem

There's a couple of options to prevent CSRF from happening, of which I chose to go with the "double submit cookie" solution which requires for the API to generate a random token which get's send in an encrypted cookie as well as via the "X-CSRF-Token" header.

The idea is, that later, when submitting a form, the cookie will be (automatically) send along and I manually attach the token obtained from the header via a hidden field, or in the same header from earlier.

The problem which took me pretty long to understand is, that I was requesting the CSRF token & cookie server-side in my `loader`, which wouldn't actually set the cookie client side.
Then it took me another long while to understand that my server-side `action`, which is where I'm using `fetch` to send the actual request to my API, wouldn't include the client-side CSRF cookie needed to verify, even when setting `credentials: "include"` in the `fetch` request.

## Solution

After trying tons of (crazy) things, really not sure where I had my mind üò≥, I realized that I have to manually forward the cookie from the server to the client and vice versa. ü§¶üèª‚Äç‚ôÇÔ∏è

### Code examples

```ts

```

## CSRF related links

[OWASP Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
[Cross Site Request Forgery (CSRF) by OWASP](https://owasp.org/www-community/attacks/csrf)
